<h2>Ismertesse √©s magyar√°zza el az objektum-orient√°lt fejleszt√©s n√©gy tanult alapelv√©t.</h2>

Az objektum-orient√°lt programoz√°s n√©gy alapelve seg√≠ti a fejleszt≈ëket abban, hogy a k√≥d **struktur√°ltabb, k√∂nnyebben karbantarthat√≥ √©s √∫jrafelhaszn√°lhat√≥** legyen. Az absztrakci√≥ sor√°n csak a fontos tulajdons√°gokat jelen√≠tj√ºk meg, m√≠g a r√©szleteket elrejtj√ºk. Az adatrejt√©s biztos√≠tja, hogy az objektumok bels≈ë adatai csak meghat√°rozott m√≥don √©rhet≈ëk el, √≠gy cs√∂kkentve a hib√°k lehet≈ës√©g√©t. Az √∂r√∂kl√©s lehet≈ëv√© teszi, hogy √∫j oszt√°lyokat hozzunk l√©tre megl√©v≈ëk alapj√°n, m√≠g a polimorfizmus r√©v√©n ugyanazt a m≈±veletet t√∂bbf√©le m√≥don is megval√≥s√≠thatjuk. Ez a n√©gy elv egy√ºtt alkotja az objektum-orient√°lt szeml√©let alapj√°t.


<h3>1. Absztrakci√≥ (abstraction)</h3>

Az absztrakci√≥ l√©nyege, hogy csak a l√©nyeges tulajdons√°gokat √©s m≈±veleteket jelen√≠tj√ºk meg, mik√∂zben elrejtj√ºk a felesleges r√©szleteket.
Ez azt jelenti, hogy a programoz√≥ nem minden apr√≥ m≈±k√∂d√©si r√©szletet mutat meg a felhaszn√°l√≥nak, csak azt, ami sz√ºks√©ges az adott szitu√°ci√≥ban.

üîπ P√©lda: Egy ‚ÄûAut√≥‚Äù oszt√°lyban nem kell tudni a motor bels≈ë m≈±k√∂d√©s√©t, csak azt, hogy az aut√≥t lehet ind√≠tani, f√©kezni, gyors√≠tani.
Az absztrakci√≥ seg√≠ti a k√≥d egyszer≈±s√≠t√©s√©t, √©s lehet≈ëv√© teszi, hogy a felhaszn√°l√≥ csak a k√≠v√°nt funkcionalit√°ssal tal√°lkozzon.


<h3>2. Adatrejt√©s (Encapsulation)</h3>

Az adatrejt√©s c√©lja, hogy az objektum bels≈ë √°llapota (adatai) csak meghat√°rozott m√≥don legyen el√©rhet≈ë vagy m√≥dos√≠that√≥. Ez a ‚Äûbels≈ë r√©szletek elrejt√©se‚Äù, √©s v√©delmet ny√∫jt a hib√°s haszn√°lat ellen.

Az oszt√°ly priv√°t v√°ltoz√≥kat √©s publikus met√≥dusokat haszn√°lhat, √≠gy a k√≠v√ºl√°ll√≥k nem f√©rnek k√∂zvetlen√ºl az adatokhoz, csak az oszt√°ly √°ltal enged√©lyezett m√≥don.

üîπ P√©lda: Egy ‚ÄûBankAccount‚Äù oszt√°lyban a sz√°mlaegyenleget nem m√≥dos√≠thatja k√∂zvetlen√ºl senki ‚Äì csak a deposit() vagy withdraw() met√≥duson kereszt√ºl.

Ez megakad√°lyozza a v√©letlen hib√°kat √©s biztos√≠tja az adatok integrit√°s√°t.

<h3>3. √ñr√∂kl√©s (Inheritance)</h3>

Az √∂r√∂kl√©s lehet≈ëv√© teszi, hogy egy √∫j oszt√°ly (gyermek) √°tvegye egy m√°sik oszt√°ly (sz√ºl≈ë) tulajdons√°gait √©s viselked√©s√©t.
Ez√°ltal √∫j oszt√°lyokat hozhatunk l√©tre a megl√©v≈ëk alapj√°n an√©lk√ºl, hogy a teljes k√≥dot √∫jra√≠rn√°nk.

üîπ P√©lda: Ha van egy √Ållat oszt√°ly, akkor a Kutya √©s Macska oszt√°ly √∂r√∂k√∂lheti az ‚Äûeszik‚Äù vagy ‚Äûalszik‚Äù met√≥dusokat. Emellett saj√°t funkci√≥kat is hozz√°adhat (pl. ‚Äûugat‚Äù).

Ez n√∂veli a k√≥d √∫jrafelhaszn√°lhat√≥s√°g√°t √©s modularit√°s√°t.

<h3>4. Polimorfizmus (Polymorphism)</h3>

A polimorfizmus azt jelenti, hogy ugyanazt a m≈±veletet t√∂bbf√©lek√©ppen hajthatjuk v√©gre, az adott objektum t√≠pus√°t√≥l f√ºgg≈ëen. Ez a ‚Äût√∂bbalak√∫s√°g‚Äù.

K√©t form√°ja van:

Fut√°sidej≈± polimorfizmus (pl. met√≥dus fel√ºldefini√°l√°s ‚Äì override)

Ford√≠t√°sidej≈± polimorfizmus (pl. met√≥dus t√∫lterhel√©s ‚Äì overload)

üîπ P√©lda: A rajzol() met√≥dus lehet m√°s a K√∂r oszt√°lyban √©s a N√©gyzet oszt√°lyban, m√©gis ugyan√∫gy h√≠vjuk meg ≈ëket. A rendszer fut√°sid≈ëben d√∂nti el, melyik verzi√≥t haszn√°lja.

Ez teszi lehet≈ëv√© a rugalmas √©s √°ltal√°nos megold√°sokat.
